{"version":3,"sources":["components/errorMsg/ErrorMsg.js","components/carousel/Carousel.js","components/mosaicBtn/MosaicBtn.js","components/mosaic/Mosaic.js","service/getPhotoData.js","App.js","serviceWorker.js","index.js"],"names":["ErrorMsg","className","Carousel","props","err","photoData","isFirstImg","isLastImg","activeImgIndex","length","indicators","map","el","index","key","id","src","urls","small","alt","alt_description","onClick","handlePhotoChange","imgRow","regular","data-testid","style","transform","MosaicBtn","closePopUp","disabled","Mosaic","isPopUp","photoGrid","imgUrl","backgroundImage","a","async","axios","get","response","data","App","state","mode","fetchData","getPhotoData","console","log","setState","results","imgIndex","handleModeChange","this","React","Component","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.25b9697a.chunk.js","sourcesContent":["import React from \"react\";\nimport \"./ErrorMsg.css\";\n\nconst ErrorMsg = () => {\n  return <h1 className=\"err-msg\">Something goes wrong</h1>;\n};\n\nexport default ErrorMsg;\n","import React from \"react\";\nimport ErrorMsg from \"../errorMsg/ErrorMsg\";\nimport \"./Carousel.css\";\n\nconst Carousel = props => {\n  if (props.err) {\n    return <ErrorMsg />;\n  }\n\n  if (!props.photoData) {\n    return <></>;\n  }\n\n  let { photoData, activeImgIndex } = props;\n\n  let isFirstImg;\n  let isLastImg;\n\n  if (activeImgIndex === 0) {\n    isFirstImg = true;\n  } else if (activeImgIndex === photoData.length - 1) {\n    isLastImg = true;\n  }\n\n  const indicators = [...props.photoData].map((el, index) => {\n    return (\n      <img\n        key={el.id}\n        src={el.urls.small}\n        alt={`${el.alt_description}_thumbnails`}\n        className={`panel__thumbnails ${\n          index === activeImgIndex ? `active` : \"\"\n        }`}\n        onClick={() => props.handlePhotoChange(index)}\n      />\n    );\n  });\n\n  let imgRow = [...props.photoData].map((el, index) => {\n    return (\n      <img\n        key={index}\n        className={`carousel__img ${index === activeImgIndex ? `active` : \"\"}`}\n        src={el.urls.regular}\n        alt={el.alt_description}\n      />\n    );\n  });\n\n  return (\n    <div>\n      <div className=\"panel\">\n        <button\n          data-testid=\"previous-img-button\"\n          className={`${isFirstImg ? \"button__hide\" : \"button__arrow \"}`}\n          onClick={() => props.handlePhotoChange(activeImgIndex - 1)}\n        >\n          &#9664;\n        </button>\n        <div>{indicators}</div>\n        <button\n          data-testid=\"next-img-button\"\n          className={`${isLastImg ? \"button__hide\" : \"button__arrow\"}`}\n          onClick={() => props.handlePhotoChange(activeImgIndex + 1)}\n        >\n          &#9654;\n        </button>\n      </div>\n\n      <div className=\"carousel\">\n        <div\n          className=\"carousel__slide\"\n          style={{\n            transform: `translateX(-${(activeImgIndex / photoData.length) *\n              100}%)`\n          }}\n        >\n          {imgRow}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default Carousel;\n","import React from \"react\";\nimport \"./MosaicBtn.css\";\n\nconst MosaicBtn = props => {\n  const { activeImgIndex, photoData } = props;\n\n  let isFirstImg;\n  let isLastImg;\n\n  if (activeImgIndex === 0) {\n    isFirstImg = true;\n  } else if (activeImgIndex === photoData.length - 1) {\n    isLastImg = true;\n  }\n\n  return (\n    <div className=\"mosaic__btn-wrapper\">\n      <button className=\"mosaic__btn close\" onClick={props.closePopUp}>\n        &#10005;\n      </button>\n      <button\n        className={`mosaic__btn left ${isFirstImg ? \"disabled\" : \"\"}`}\n        disabled={isFirstImg}\n        onClick={() => props.handlePhotoChange(activeImgIndex - 1)}\n      >\n        &#8592;\n      </button>\n      <button\n        className={`mosaic__btn right ${isLastImg ? \"disabled\" : \"\"}`}\n        disabled={isLastImg}\n        onClick={() => props.handlePhotoChange(activeImgIndex + 1)}\n      >\n        &#8594;\n      </button>\n    </div>\n  );\n};\n\nexport default MosaicBtn;\n","import React from \"react\";\nimport \"./Mosaic.css\";\nimport MosaicBtn from \"../mosaicBtn/MosaicBtn\";\nimport ErrorMsg from \"../errorMsg/ErrorMsg\";\n\nconst Mosaic = props => {\n  if (props.err) {\n    return <ErrorMsg />;\n  }\n\n  if (!props.photoData) {\n    return <></>;\n  }\n\n  const { photoData, activeImgIndex, isPopUp } = props;\n\n  let photoGrid = [...photoData].map((el, index) => {\n    let imgUrl = el.urls.regular;\n\n    return (\n      <div\n        key={el.id}\n        className={`mosaic__items mosaic__items-${index + 1} ${\n          index === activeImgIndex && isPopUp ? `active` : ``\n        }`}\n        style={{ backgroundImage: `url(${imgUrl})` }}\n        onClick={() => props.handlePhotoChange(index)}\n      ></div>\n    );\n  });\n\n  return (\n    <>\n      <div className=\"mosaic\">\n        {photoGrid}\n        {isPopUp ? (\n          <MosaicBtn\n            photoData={photoData}\n            activeImgIndex={props.activeImgIndex}\n            handlePhotoChange={props.handlePhotoChange}\n            isPopUp={props.isPopUp}\n            closePopUp={props.closePopUp}\n          />\n        ) : (\n          \"\"\n        )}\n      </div>\n    </>\n  );\n};\n\nexport default Mosaic;\n","import axios from \"axios\";\n\nexport default async () => {\n  const response = await axios.get(\"/api/photos\");\n  return response.data;\n};\n","import React from \"react\";\nimport \"./App.css\";\nimport Carousel from \"./components/carousel/Carousel\";\nimport Mosaic from \"./components/mosaic/Mosaic\";\nimport getPhotoData from \"./service/getPhotoData\";\n\nclass App extends React.Component {\n  state = {\n    photoData: \"\",\n    activeImgIndex: 0,\n    mode: \"mosaic\",\n    isPopUp: false\n  };\n\n  componentDidMount() {\n    this.fetchData();\n  }\n\n  fetchData = async () => {\n    try {\n      const response = await getPhotoData();\n\n      if (response.err) {\n        console.log(\"fetch data err from backend:\", response.err);\n        return this.setState({ err: response.err });\n      }\n\n      this.setState({ photoData: response.results });\n    } catch (err) {\n      console.log(\"fetch data err from front-end:\", err);\n      this.setState({ err });\n    }\n  };\n\n  handlePhotoChange = imgIndex => {\n    this.setState({\n      activeImgIndex: imgIndex\n    });\n    if (this.state.mode === \"mosaic\") {\n      this.setState({\n        isPopUp: true\n      });\n    }\n  };\n\n  handleModeChange = mode => {\n    this.setState({ mode });\n\n    // close popUp when unmount mosaic component\n    if (this.state.mode === \"mosaic\") {\n      this.setState({\n        isPopUp: false\n      });\n    }\n  };\n\n  closePopUp = () => {\n    this.setState({ isPopUp: false, activeImgIndex: 0 });\n  };\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"nav\">\n          <button\n            className={`nav__modeBtn ${\n              this.state.mode === \"mosaic\" ? \"active\" : \"\"\n            }`}\n            onClick={() => this.handleModeChange(\"mosaic\")}\n          >\n            mosaic\n          </button>\n          <button\n            className={`nav__modeBtn ${\n              this.state.mode === \"carousel\" ? \"active\" : \"\"\n            }`}\n            onClick={() => this.handleModeChange(\"carousel\")}\n          >\n            carousel\n          </button>\n        </div>\n\n        {this.state.mode === \"mosaic\" && (\n          <Mosaic\n            photoData={this.state.photoData}\n            activeImgIndex={this.state.activeImgIndex}\n            handlePhotoChange={this.handlePhotoChange}\n            err={this.state.err}\n            isPopUp={this.state.isPopUp}\n            closePopUp={this.closePopUp}\n          />\n        )}\n        {this.state.mode === \"carousel\" && (\n          <Carousel\n            photoData={this.state.photoData}\n            activeImgIndex={this.state.activeImgIndex}\n            handlePhotoChange={this.handlePhotoChange}\n            err={this.state.err}\n          />\n        )}\n      </div>\n    );\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' }\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { BrowserRouter } from \"react-router-dom\";\n\nReactDOM.render(\n  <BrowserRouter>\n    <App />\n  </BrowserRouter>,\n  document.getElementById(\"root\")\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}